---
title: "INLA-Hyper-Learning"
author: "Jeffrey Wu"
date: "2024-06-25"
output: html_document
---

Load all relevant packages:

```{r,warning=FALSE,echo=FALSE}
library(dplyr) 
library(tidyverse)
library(lubridate)
library(stringr)
library(zoo)
library(ggplot2)
library(urbnmapr)
library(devtools)
library(readxl)
library(spdep)
library(sp)
library(huge)
library(INLA)
library(HMMpa)
library(invgamma)
library(brinla)
library(reshape2)
library(patchwork)
library(jsonlite)
library(geosphere)
library(urbnmapr)
library(RAQSAPI)
library(con2aqi)
library(pscl)
library(randtoolbox)
library(lhs)
```

# Load workspace from INLA 2.1

```{r}
# load("INLA-2.1-Premodel-6.25.RData")
```

# Load workspace from INLA 2.2

```{r}
# load("INLA-2.2-Premodel-6.15.RData")
```

# Load workspace from INLA 2.3

```{r}
load("INLA-2.3-Premodel-6.25.RData")
```

# Load workspace from INLA 7.1

```{r}
# load("INLA-7.1-Premodel-6.25.RData")
```

# Load workspace from INLA 7.2

```{r}
# load("INLA-7.2-5.18.RData")
```

# Load workspace from INLA 7.3

```{r}
# load("INLA-7.3-Premodel-6.25.RData")
```

# Functions needed for INLA models

```{r}
EPA_kernel = function(EPA_data = final_EPA_agg_data,time_span,rho_rbf,rho_periodic,sigma2){
  K_EPA = matrix(0,nrow=time_span,ncol=time_span)
  i = 1
  j = 1
  
  for(t1 in 1:time_span){
    for (t2 in 1:time_span){
      A = EPA_data %>% filter(Time == t1)
      B = EPA_data %>% filter(Time == t2)
      AQIa = unique(A$AQI)
      AQIb = unique(B$AQI)
      
      ABtest = c((A$Value-B$Value)^2,(AQIa-AQIb)^2) #7 clusters * 8 measurements 
      # K_EPA[i,j] = exp(-sum(ABtest) / (2*rho_rbf)) * sigma2
      
      K_EPA[i,j] = exp(- (sum(ABtest)^2)
                     / (2*rho_rbf)) * exp(- (2*sin(sum(abs(ABtest))*3.14/12)^2)
                     / (rho_periodic)) * sigma2
      
      j = j+1
    }
    
    j = 1
    i = i+1
  }
  
  return(K_EPA)
}
```


## Ensuring precision matrix is not computationally singular, so we jitter eigenvalues, using reciprocal condition number as constraint

```{r}
desingularize = function(covmatrix,threshold = 1e-2,increment = 0.01){
  
  tracker = 0
  
  while (rcond(covmatrix) <= threshold){
    #Perform spectral decomposition
    ev = eigen(covmatrix)
    L = ev$values
    V = ev$vectors
    
    # #Add a little noise to eigenvalues to bring away from 0
    L = L + increment
    
    # #Add 0.01 to eigenvalues in bottom five percentile to bring away from 0
    # cutoff = quantile(abs(L),0.05)
    # L[which(abs(L) < cutoff)] = L[which(abs(L) < cutoff)] + 0.01
    
    #Calculate new precision matrix 
    covmatrix = V %*% diag(L) %*% t(V)
    
    tracker = tracker + 1
  }
  
  results_list = list(covmatrix,tracker)
  #sprintf("%s iterations of desingularizer applied",tracker)
  return(results_list)
}

# test = desingularize(K_time)
```

## Calculating simple time kernel K

```{r}
time_kernel = function(time_span,rho_rbf,rho_periodic,sigma2){
  K_time = matrix(NA,nrow = time_span, ncol = time_span)
  
  for (i in 1:time_span){
    for (j in 1:time_span){
      # K_time[i,j] = exp(- (abs(i-j)^2) / (2*rho)) * sigma2
      
      K_time[i,j] = exp(- (abs(i-j)^2) / (2*rho_rbf)) * exp(- (2*sin(sum(abs(i-j))*3.14/12)^2)
                     / (rho_periodic)) * sigma2
    }
  }
  
  return(K_time)
}
```


# IN SAMPLE FITTING ANALYSIS

## Fit a simple Poisson GLMM for our mortality data (Reference model 1)

We wanted to compare the performance of our proposed model with a few reference models. The first one is a Poisson generalized linear mixed model. This model assumes the observed data follows a Poisson distribution and the hyperparameter $\lambda_i$ can be modeled using a mixed effects model with a log link.

In other words,

$Y_{i,t} \sim Pois(\lambda_{i,t})$ for $i=1,...,6$ and $t=1,...,72$ where $log(\lambda_{i,t}) = \beta_0 + \beta_1 * I \{t=2,14,...,62 \} + ... + \beta_{11} * I \{t=12,24,...,72 \} + u_i$

where the random effect $u_i \sim MVN(0,\tau \Sigma)$

We wanted the first reference model to be simple, so we assumed that the random effects $u_i$ are iid. This means that $\Sigma$ is simply a diagonal matrix of scaling factors. The hyperparameter $log(\tau)$ is by default assigned a $log \; \Gamma(1,0.00005)$ prior.

```{r}
#Write a function to fit our poisson glmm in INLA 
ref_model1 = function(dataset,a_prior = 1,b_prior = 5e-05,link=1){
  ###Fit INLA model 
  prec_prior <- list(prec = list(prior = "loggamma", param = c(a_prior,b_prior)))
  # ref_formula1 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id,model = "iid", hyper = prec_prior) #could use id or id2 
  ref_formula1 = response ~ -1 + months + Intercept1 + Intercept2 + f(id,model = "iid", hyper = prec_prior) #could use id or id2 
  
  model = inla(formula = ref_formula1,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  ref_model1_results = list(
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model
  )
  
  return(ref_model1_results)
}
```

```{r,warning=FALSE,eval=FALSE}
#Write a function to make plot of posterior predictive estimates with credible interval bands OVERLAID on response
pp_insample_plot = function(num_plots = num_clus, ref_data = inla_insample_data, pred_data){
  for (i in 1:num_plots){
  df = ref_data %>% filter(id == i) %>% select(response)
  preds = pred_data %>% filter(id == i) 
  df = cbind(df,preds)
  
  title = sprintf("Posterior Predictive Fits for Cluster %s",i)
  
  post_pred_plot = df %>% ggplot(aes(x=time,y=response)) + geom_point() + 
    geom_line(aes(y=mean),color = "red") + geom_ribbon(aes(ymin = `0.025quant`,ymax = `0.975quant`),alpha = 0.3) + ggtitle(title)
  print(post_pred_plot)
  }
}

#Test function 
pp_insample_plot(pred_data = test$fitted_values)
```

# Defining grid of hyperparameter value pairs

```{r}
a_prior = seq(0.1,1,length=5)
b_prior = seq(0.00001,0.1,length=5)

hyper_grid = matrix(ncol=2)

for (i in a_prior){
  for(j in b_prior){
    hyper_grid = rbind(hyper_grid,c(i,j))
  }
} 

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("alpha","beta")
```

```{r,warning=FALSE}
#Need to try apply on this function(), store each list of results as item of a bigger list
# Define a function to apply kgr_model3 to each row
apply_function <- function(row) {
  a_prior <- row[1]
  b_prior <- row[2]
  
  # Call your ref_model1 function with the specific hyperparameters
  result <- ref_model1(dataset = inla_insample_data,a_prior = a_prior,b_prior = b_prior)
  
  # Return the result
  return(result)
}

# Apply the function to each row of the matrix
ref_model1_results_list <- apply(hyper_grid, 1, apply_function)

# #Extracting DIC values 
# ref_model1_results_DIC = c()
# 
# for (i in 1:length(ref_model1_results_list)){
#   ref_model1_results_DIC[i] = pred_data = ref_model1_results_list[[i]]$model_DIC
# }
# 
# hist(ref_model1_results_DIC)
# top5 = head(sort(ref_model1_results_DIC))
# top5
# which(ref_model1_results_DIC <= top5[5])
# 
# ref_model1_results_DIC = cbind(hyper_grid,ref_model1_results_DIC)

#Extracting WAIC values 
ref_model1_results_WAIC = c()

for (i in 1:length(ref_model1_results_list)){
  ref_model1_results_WAIC[i] = pred_data = ref_model1_results_list[[i]]$model_WAIC
}

hist(ref_model1_results_WAIC)
top5 = head(sort(ref_model1_results_WAIC))
top5
top5_idx = which(ref_model1_results_WAIC <= top5[5])

ref_model1_results_WAIC = cbind(hyper_grid,ref_model1_results_WAIC)
colnames(ref_model1_results_WAIC) = c(colnames(hyper_grid),"WAIC")
ref_model1_results_WAIC[top5_idx,]

# #Plot WAIC values for each hyperparameter grid 
# for (i in 1:2){
#   plot(x = ref_model1_results_WAIC[,i],y = ref_model1_results_WAIC[,3],xlab = colnames(ref_model1_results_WAIC)[i],ylab = "WAIC")
# }
```

Best hyperparameter values (so far): (0.1,0.1) , WAIC= 4648.214 (very flat no difference)

## Fitting a Besag-York-Mollie model (Reference model 2)

For our second reference model, we decided to fit a Besag-York-Mollie model, which is a log-normal Poisson model with an intrinsic conditional autoregressive component to capture spatial autocorrelations i.e. a Besag model, plus a standard random effects term which is included to capture non-spatial heterogeneity. Obviously, this model is less naive than reference model 1 because it does not assume iid random effects.

The BYM model can be written as,

$Y_{i,t} \sim Pois(\lambda_{i,t})$ for $i=1,...,6$ and $t=1,...,72$ where $log(\lambda_{i,t}) = \beta_0 + \beta_1 * I \{t=2,14,...,62 \} + ... + \beta_{11} * I \{t=12,24,...,72 \} + \phi_i + u_i$

where $p(\phi) \propto exp(-\frac{1}{2} \sum_{i \sim j} (\phi_i - \phi_j)^2)$ and $u_i \sim MVN(0,\tau \Sigma)$.

Note: it is more commonly known that ICAR components are conditionally normally distributed.

As one can see below, the summary outputs indicate that this model is very similar to the Poisson GLMM (reference model 1). The intercept and SD for the random effect component are estimated to almost the exact same as those estimated by the Poisson GLMM, indicating that including the spatial ICAR component is seemingly not very impactful.

```{r}
#Write a function to fit our BYM model in INLA 
ref_model2 = function(dataset,a_prec_prior = 1,b_prec_prior = 5e-04,a_phi_prior = 1,b_phi_prior = 5e-04,link=1){
  ###Fit INLA model 
  bym_prior <- list(
  prec.unstruct = list(
    prior = "loggamma",
    param = c(a_prec_prior,b_prec_prior)),
  prec.spatial = list(
    prior = "loggamma",
    param = c(a_phi_prior,b_phi_prior))
  )
  # ref_formula2 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + 
  #   f(id, model = "bym", graph = huge.est, hyper = bym_prior) #ID2 in formula results in error
   ref_formula2 = response ~ -1 + months + Intercept1 + Intercept2 + 
    f(id, model = "bym", graph = huge.est, hyper = bym_prior) #ID2 in formula results in error
  
  model = inla(formula = ref_formula2,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  ref_model2_results = list(
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model
  )
  
  return(ref_model2_results)
}
```

# Defining grid of hyperparameter value pairs

```{r}
a_phi_prior = seq(1,5,length=5)
b_phi_prior = seq(0.001,1,length=5)

hyper_grid = matrix(ncol=2)

for (i in a_phi_prior){
  for(j in b_phi_prior){
    hyper_grid = rbind(hyper_grid,c(i,j))
  }
} 

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("alpha","beta")
```

```{r,warning=FALSE}
#Need to try apply on this function(), store each list of results as item of a bigger list
# Define a function to apply kgr_model3 to each row
apply_function <- function(row) {
  a_phi_prior <- row[1]
  b_phi_prior <- row[2]
  
  # Call your ref_model1 function with the specific hyperparameters
  result <- ref_model2(dataset = inla_insample_data,a_prec_prior = 1,b_prec_prior = 0.001,
                       a_phi_prior = a_phi_prior,b_phi_prior = b_phi_prior)
  
  # Return the result
  return(result)
}

# Apply the function to each row of the matrix
ref_model2_results_list <- apply(hyper_grid, 1, apply_function)

# #Extracting DIC values 
# ref_model2_results_DIC = c()
# 
# for (i in 1:length(ref_model2_results_list)){
#   ref_model2_results_DIC[i] = pred_data = ref_model2_results_list[[i]]$model_DIC
# }
# 
# hist(ref_model2_results_DIC)
# top5 = head(sort(ref_model2_results_DIC))
# top5
# which(ref_model2_results_DIC <= top5[5])
# 
# ref_model2_results_DIC = cbind(hyper_grid,ref_model2_results_DIC)

#Extracting WAIC values 
ref_model2_results_WAIC = c()

for (i in 1:length(ref_model2_results_list)){
  ref_model2_results_WAIC[i] = pred_data = ref_model2_results_list[[i]]$model_WAIC
}

hist(ref_model2_results_WAIC)
top5 = head(sort(ref_model2_results_WAIC))
top5
top5_idx = which(ref_model2_results_WAIC <= top5[5])

ref_model2_results_WAIC = cbind(hyper_grid,ref_model2_results_WAIC)
colnames(ref_model2_results_WAIC) = c(colnames(hyper_grid),"WAIC")
ref_model2_results_WAIC[top5_idx,]

# #Plot WAIC values for each hyperparameter grid 
# for (i in 1:2){
#   plot(x = ref_model2_results_WAIC[,i],y = ref_model2_results_WAIC[,3],xlab = colnames(ref_model2_results_WAIC)[i],ylab = "WAIC")
# }
```

Best hyperparameter values (so far): (0.1,0.1) for prec and (4,0.5005) for phi , WAIC = 4648.238 (very flat no difference)

## Fitting kernel graph regression models

Finally, we fit our proposed model which we call a kernel graph regression model. It also takes the form of a latent Gaussian model as shown below:

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{i,t} | \textbf{X} = exp(\beta_0 + F_{i,t})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,K \otimes H^2)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = k(x_{t_1},x_{t_2})(H^2)_{n_1,n_2}$.

## KGR model with time series kernel x graph filter (Proposed model 2)

GLMM with type 0 generic specification (known covariance matrix)

```{r,warning=FALSE}
kgr_model2 = function(dataset, rho_EPA_rbf = 1, rho_EPA_periodic = 1, sigma2_EPA = 1,link=1){
  
  #Calculate gram matrix K_EPA
  K_EPA = EPA_kernel(time_span = length(unique(dataset$time)),
                     rho_rbf = rho_EPA_rbf, rho_periodic = rho_EPA_periodic, sigma2 = sigma2_EPA)
  
  #Heatmap of resulting K 
  #K_EPA_heatmap = matrix_heatmap(K_EPA,title = "K_EPA Heatmap")
  
  #Calculate trace norm of gram matrix
  K_EPA_weight = norm(K_EPA,type = "F")
  
  ###Load graph regression kernel 
  covGP = kronecker(K_EPA/60,(H^2)/7)
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(covGP,threshold = 1e-2,increment = 0.1)
  covGP = covGP_jittered[[1]]
  inv_covGP = solve(covGP)
  # cov_Fnorm = norm(covGP,type = "F")
  
  #Heatmap of resulting K 
  #inv_covGP_heatmap = matrix_heatmap(inv_covGP,title = "Precision matrix heatmap")
  
  ###Fit INLA model 
  # kgr_formula2 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP)
  
  # kgr_formula2 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP)
  kgr_formula2 = response ~ -1 + months + Intercept1 + Intercept2 + f(id2,model = "generic0",Cmatrix = inv_covGP)
  
  model = inla(formula = kgr_formula2,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE,
                                         return.marginals.predictor=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  # ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  # marginal_fvs <- model$marginals.fitted.values

  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  kgr_model2_results = list(
    # K_EPA_heatmap = K_EPA_heatmap,
    # K_EPA_weight = K_EPA_weight/(K_EPA_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_EPA_weight + gfilter_weight),
    # covmatrix = covGP,
    # prec = inv_covGP,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_covGP_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model,
    # marg_fitted_values = marginal_fvs
  )
  
  return(kgr_model2_results)
}
```

```{r,eval=FALSE}
rho_EPA_rbf_grid = seq(60,80,length=5)
rho_EPA_periodic_grid = seq(5,15,length=5)
sigma2_EPA_grid = seq(180,220,length = 5)

hyper_grid = matrix(ncol=3)

for (i in rho_EPA_rbf_grid){
  for (j in rho_EPA_periodic_grid){
      for(k in sigma2_EPA_grid){
        hyper_grid = rbind(hyper_grid,c(i,j,k))
    }  
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_EPA_rbf","rho_EPA_periodic","sigma2_EPA")
```

```{r}
hyper_grid2 = randomLHS(100,3)
colnames(hyper_grid2) = c("rho_EPA_rbf","rho_EPA_periodic","sigma2_EPA")
hyper_grid2[,1:2] = hyper_grid2[,1:2]*205 
hyper_grid2[,3] = hyper_grid2[,3]*5 
```

```{r,warning=FALSE}
# kgr_model2_running_results = c()
# 
# apply_function <- function(row,index) {
#   rho_EPA_rbf <- row[1]
#   rho_EPA_periodic <- row[2]
#   sigma2_EPA <- row[3]
#   
#   # Call kgr_model2 function with the specific hyperparameters
#   result <- kgr_model2(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
#                        rho_EPA_periodic = rho_EPA_periodic, sigma2_EPA = sigma2_EPA)
#   
#   # Print and save WAIC every 100th model
#   if (index %% 5 == 0) {
#     cat("Model", index, "WAIC:", result$model_WAIC, "\n")
#     kgr_model2_running_results = c(kgr_model2_running_results , result$model_WAIC)
#     saveRDS(kgr_model2_running_results, paste0("kgr_model2_running_results_WAIC.rds"))
#   }
#   
#   # Return the result
#   return(result)
# }
# 
# kgr_model2_results_list <- lapply(seq_len(nrow(hyper_grid)), function(i) {
#   apply_function(hyper_grid[i, ], i)
# })


apply_function <- function(row, index) {
  rho_EPA_rbf <- row[1]
  rho_EPA_periodic <- row[2]
  sigma2_EPA <- row[3]

  result <- tryCatch(
    {
      # Call kgr_model2 function with the specific hyperparameters
      kgr_model2(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
                 rho_EPA_periodic = rho_EPA_periodic, sigma2_EPA = sigma2_EPA)
    },
    error = function(e) {
      # Handle the error by printing a message and returning NULL
      cat("Error in model", index, ":", conditionMessage(e), "\n")
      return(NULL)
    }
  )

  # If result is not NULL, process the result
  if (!is.null(result)) {
    # Print and save WAIC every 5th model
    if (index %% 5 == 0) {
      cat("Model", index, "WAIC:", result$model_WAIC, "\n")
      kgr_model2_running_results <<- c(kgr_model2_running_results, result$model_WAIC)
      saveRDS(kgr_model2_running_results, paste0("kgr_model2_running_results_WAIC.rds"))
    }
  }

  # Return the result (which could be NULL if there was an error)
  return(result)
}

kgr_model2_running_results <- vector()  # Initialize an empty vector to store WAIC results

kgr_model2_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# Remove NULL results from the list if needed
kgr_model2_results_list <- Filter(Negate(is.null), kgr_model2_results_list)



#Extracting DIC values 
kgr_model2_results_DIC = c()

for (i in 1:length(kgr_model2_results_list)){
  kgr_model2_results_DIC[i] = pred_data = kgr_model2_results_list[[i]]$model_DIC
}

hist(kgr_model2_results_DIC)
top5 = head(sort(kgr_model2_results_DIC))
top5
which(kgr_model2_results_DIC <= top5[5])

kgr_model2_results_DIC = cbind(hyper_grid2,kgr_model2_results_DIC)

#Extracting WAIC values 
kgr_model2_results_WAIC = c()

for (i in 1:length(kgr_model2_results_list)){
  kgr_model2_results_WAIC[i] = pred_data = kgr_model2_results_list[[i]]$model_WAIC
}


saveRDS(kgr_model2_results_WAIC, paste0("kgr_model2_results_WAIC.rds"))


hist(kgr_model2_results_WAIC)
top5 = head(sort(kgr_model2_results_WAIC))
top5
top5_idx = which(kgr_model2_results_WAIC <= top5[5])

kgr_model2_results_WAIC = cbind(hyper_grid2,kgr_model2_results_WAIC)
colnames(kgr_model2_results_WAIC) = c(colnames(hyper_grid2),"WAIC")
kgr_model2_results_WAIC[top5_idx,]
```

Best hyperparameter values (so far): (rho_EPA_rbf,rho_EPA_periodic,sigma2_EPA) = (60,5,220) , WAIC = 2806.668

We can also simplify the covariance of our underlying GP and see how our proposed model compares with a simplified version with a simple time kernel:

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{t} | \textbf{X} = exp(\beta_0 + F_{t})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,Ktime)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = k(t_1,t_2)$.

Instead of calculating gram matrix K based on covariate (EPA variables) similarity, our gram matrix K is simply a time kernel where similar values of t (months 1-72) have larger covariances. As a result, this model has no spatial dependence structure built in.

## LGCP with temporal kernel (Reference model 3)

Since there is no spatial component in this model, each cluster can be fit separately.

```{r,warning=FALSE}
ref_model3 = function(dataset, cluster, rho_time_rbf = 1, rho_time_periodic = 1, sigma2_time = 1,link=1){
  
  #Calculating gram matrix K_time
  K_time = time_kernel(time_span = length(unique(dataset$time)),rho_rbf = rho_time_rbf, 
                       rho_periodic = rho_time_periodic, sigma2 = sigma2_time)
  
  #Heatmap of resulting K 
  #K_time_heatmap = matrix_heatmap(K_time,title = "K_time heatmap")
  
  #Calculate trace norm of gram matrix
  K_time_weight = norm(K_time,type = "F")
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(K_time,threshold = 1e-2,increment = 0.01)
  K_time = covGP_jittered[[1]]
  inv_K_time = solve(K_time)
  # cov_Fnorm = norm(K_time,type = "F")

  
  #Heatmap of resulting inv_K_time 
  #inv_K_time_heatmap = matrix_heatmap(inv_K_time,title = "Precision matrix heatmap")
  
  
  ###Fitting the model on each cluster 
  inla_test_clus_data = dataset %>% filter(id == cluster)
  
  # ref_formula3 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(time,model = "generic0",Cmatrix = inv_K_time)
  ref_formula3 = response ~ -1 + Intercept1 + Intercept2 + f(time,model = "generic0",Cmatrix = inv_K_time)
  
  model = inla(ref_formula3, data = inla_test_clus_data, family = "poisson",
                    control.compute = list(dic=TRUE,waic=TRUE),
                    control.inla = list(strategy = "laplace"),
                    control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(inla_test_clus_data$id, inla_test_clus_data$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  ref_model3_results = list(
    # K_time_heatmap = K_time_heatmap,
    # K_time_weight = K_time_weight/(K_time_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_time_weight + gfilter_weight),
    # covmatrix = K_time,
    # prec = inv_K_time,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_K_time_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model
  )
  
  return(ref_model3_results)
}
```

```{r,warning=FALSE,eval=FALSE}
rho_time_rbf_grid = seq(1,50,length=5)
rho_time_periodic_grid = seq(1,50,length=5)
sigma2_time_grid = seq(10,1000,length = 5)

hyper_grid = matrix(ncol=3)

for (i in rho_time_rbf_grid){
  for (j in rho_time_periodic_grid){
      for(k in sigma2_time_grid){
        hyper_grid = rbind(hyper_grid,c(i,j,k))
    }  
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_time_rbf","rho_time_periodic","sigma2_time")
```

```{r}
hyper_grid2 = randomLHS(100,3)
colnames(hyper_grid2) = c("rho_time_rbf","rho_time_periodic","sigma2_time")
hyper_grid2[,1:2] = hyper_grid2[,1:2]*600 
hyper_grid2[,3] = hyper_grid2[,3]*5 
```

```{r,warning=FALSE}
# #Need to try apply on this function(), store each list of results as item of a bigger list
# # Define a function to apply kgr_model3 to each row
# apply_function <- function(row) {
#   rho_time_rbf <- row[1]
#   rho_time_periodic <- row[2]
#   sigma2_time <- row[3]
#   
#   # Call your kgr_model3 function with the specific hyperparameters
#   result <- ref_model3(dataset = inla_insample_data, cluster = 1, rho_time_rbf = rho_time_rbf,
#                        rho_time_periodic = rho_time_periodic, sigma2_time = sigma2_time)
#   
#   # Return the result
#   return(result)
# }
# 
# # Apply the function to each row of the matrix
# ref_model3_results_list <- apply(hyper_grid2, 1, apply_function)
# 
# # #Posterior predictive plots
# # for (i in 1:length(kgr_model4_results_list)){
# #   pp_insample_plot(pred_data = kgr_model4_results_list[[i]]$fitted_values)
# # }

apply_function <- function(row, index) {
  rho_time_rbf <- row[1]
  rho_time_periodic <- row[2]
  sigma2_time <- row[3]

  result <- tryCatch(
    {
      ref_model3(dataset = inla_insample_data, cluster = 2, rho_time_rbf = rho_time_rbf,
                        rho_time_periodic = rho_time_periodic, sigma2_time = sigma2_time)
    },
    error = function(e) {
      # Handle the error by printing a message and returning NULL
      cat("Error in model", index, ":", conditionMessage(e), "\n")
      return(NULL)
    }
  )

  # If result is not NULL, process the result
  if (!is.null(result)) {
    # Print and save WAIC every 5th model
    if (index %% 20 == 0) {
      cat("Model", index, "WAIC:", result$model_WAIC, "\n")
      ref_model3_running_results <<- c(ref_model3_running_results, result$model_WAIC)
      saveRDS(ref_model3_running_results, paste0("ref_model3_running_results_WAIC.rds"))
    }
  }

  # Return the result (which could be NULL if there was an error)
  return(result)
}

ref_model3_running_results <- vector()  # Initialize an empty vector to store WAIC results

ref_model3_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# Remove NULL results from the list if needed
ref_model3_results_list <- Filter(Negate(is.null), ref_model3_results_list)

#Extracting DIC values 
ref_model3_results_DIC = c()

for (i in 1:length(ref_model3_results_list)){
  ref_model3_results_DIC[i] = pred_data = ref_model3_results_list[[i]]$model_DIC
}

hist(ref_model3_results_DIC)
top5 = head(sort(ref_model3_results_DIC))
top5
which(ref_model3_results_DIC <= top5[5])

ref_model3_results_DIC = cbind(hyper_grid2,ref_model3_results_DIC)

#Extracting WAIC values 
ref_model3_results_WAIC = c()

for (i in 1:length(ref_model3_results_list)){
  ref_model3_results_WAIC[i] = pred_data = ref_model3_results_list[[i]]$model_WAIC
}

hist(ref_model3_results_WAIC)
top5 = head(sort(ref_model3_results_WAIC))
top5
top5_idx = which(ref_model3_results_WAIC <= top5[5])

ref_model3_results_WAIC = cbind(hyper_grid2,ref_model3_results_WAIC)
#colnames(ref_model3_results_WAIC)[3] = "WAIC"
ref_model3_results_WAIC[top5_idx,]
```

Best hyperparameter values (so far): $(\rho_{time},\sigma^2_{time})$ = (10,10) (for cluster 4 and for cluster 6) ?? , WAIC = 234.4793 and ?? 

WEIRD BC sigma2 of 1000 fits much better and WAIC is virtually the same

## KGR model with temporal kernel x graph filter (Proposed model 1)

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{i,t} | \textbf{X} = exp(\beta_0 + F_{i,t})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,Ktime \otimes H^2)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = k(t_1,t_2)(H^2)_{n_1,n_2}$.

```{r,warning=FALSE}
kgr_model1 = function(dataset, rho_time_rbf = 1, rho_time_periodic = 1, sigma2_time = 1, link=1){
  
  #Calculating gram matrix K_time
   K_time = time_kernel(time_span = length(unique(dataset$time)),rho_rbf = rho_time_rbf, 
                        rho_periodic = rho_time_periodic, sigma2 = sigma2_time)
  
  #Heatmap of resulting K 
  #K_time_heatmap = matrix_heatmap(K_time,title = "K_time heatmap")
  
  #Calculate trace norm of gram matrix
  K_time_weight = norm(K_time,type = "F")
  
  #Calculate proposed kernel
  covGP2 = kronecker(K_time/60,(H^2)/7)
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(covGP2,threshold = 1e-2,increment = 0.1)
  covGP2 = covGP_jittered[[1]]
  
  inv_covGP2 = solve(covGP2)
  
  #Heatmap of resulting inv_covGP2 
  #inv_covGP2_heatmap = matrix_heatmap(inv_covGP2,title = "Precision matrix heatmap")
  
  ###Fit INLA model 
  # kgr_formula1 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP2)
  
  # kgr_formula1 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP2)
  kgr_formula1 = response ~ -1 + months + Intercept1 + Intercept2 + f(id2,model = "generic0",Cmatrix = inv_covGP2)
  
  model = inla(formula = kgr_formula1,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE,
                                         return.marginals.predictor=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  # marginal_fvs <- model$marginals.fitted.values
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  kgr_model1_results = list(
    # K_time_heatmap = K_time_heatmap,
    # K_time_weight = K_time_weight/(K_time_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_time_weight + gfilter_weight),
    # covmatrix = covGP2,
    # prec = inv_covGP2,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_covGP2_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model,
    # marg_fitted_values = marginal_fvs
  )
  
  return(kgr_model1_results)
}
```

```{r,warning=FALSE,eval=FALSE}
rho_time_rbf_grid = seq(1,5,length=5)
rho_time_periodic_grid = seq(1,5,length=5)
sigma2_time_grid = seq(800,1200,length = 5)

hyper_grid = matrix(ncol=3)

for (i in rho_time_rbf_grid){
  for (j in rho_time_periodic_grid){
      for(k in sigma2_time_grid){
        hyper_grid = rbind(hyper_grid,c(i,j,k))
    }  
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_time_rbf","rho_time_periodic","sigma2_time")
```

```{r}
hyper_grid2 = randomLHS(100,3)
colnames(hyper_grid2) = c("rho_time_rbf","rho_time_periodic","sigma2_time")
hyper_grid2[,1:2] = hyper_grid2[,1:2]*600 
hyper_grid2[,3] = hyper_grid2[,3]*5
```

```{r,warning=FALSE}
# kgr_model1_running_results = c()
# 
# apply_function <- function(row,index) {
#   rho_time_rbf <- row[1]
#   rho_time_periodic <- row[2]
#   sigma2_time <- row[3]
#   
#   # Call kgr_model1 function with the specific hyperparameters
#   result <- kgr_model1(dataset = inla_insample_data, rho_time_rbf = rho_time_rbf,
#                        rho_time_periodic = rho_time_periodic, sigma2_time = sigma2_time)
#   
#   # Print and save WAIC every 100th model
#   if (index %% 20 == 0) {
#     kgr_model1_running_results = c(kgr_model1_running_results , result$model_WAIC)
#     saveRDS(kgr_model1_running_results, paste0("kgr_model1_running_results_WAIC.rds"))
#   }
#   
#   # Return the result
#   return(result)
# }
# 
# kgr_model1_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
#   apply_function(hyper_grid2[i, ], i)
# })

apply_function <- function(row, index) {
  rho_time_rbf <- row[1]
  rho_time_periodic <- row[2]
  sigma2_time <- row[3]

  result <- tryCatch(
    {
      kgr_model1(dataset = inla_insample_data, rho_time_rbf = rho_time_rbf,
                       rho_time_periodic = rho_time_periodic, sigma2_time = sigma2_time)
    },
    error = function(e) {
      # Handle the error by printing a message and returning NULL
      cat("Error in model", index, ":", conditionMessage(e), "\n")
      return(NULL)
    }
  )

  # If result is not NULL, process the result
  if (!is.null(result)) {
    # Print and save WAIC every 5th model
    if (index %% 10 == 0) {
      cat("Model", index, "WAIC:", result$model_WAIC, "\n")
      kgr_model1_running_results <<- c(kgr_model1_running_results, result$model_WAIC)
      saveRDS(kgr_model1_running_results, paste0("kgr_model1_running_results_WAIC.rds"))
    }
  }

  # Return the result (which could be NULL if there was an error)
  return(result)
}

kgr_model1_running_results <- vector()  # Initialize an empty vector to store WAIC results

kgr_model1_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# Remove NULL results from the list if needed
kgr_model1_results_list <- Filter(Negate(is.null), kgr_model1_results_list)

# #Posterior predictive plots
# for (i in 1:length(kgr_model4_results_list)){
#   pp_insample_plot(pred_data = kgr_model4_results_list[[i]]$fitted_values)
# }


#Extracting DIC values 
kgr_model1_results_DIC = c()

for (i in 1:length(kgr_model1_results_list)){
  kgr_model1_results_DIC[i] = pred_data = kgr_model1_results_list[[i]]$model_DIC
}

hist(kgr_model1_results_DIC)
top5 = head(sort(kgr_model1_results_DIC))
top5
which(kgr_model1_results_DIC <= top5[5])

kgr_model1_results_DIC = cbind(hyper_grid2,kgr_model1_results_DIC)

#Extracting WAIC values 
kgr_model1_results_WAIC = c()

for (i in 1:length(kgr_model1_results_list)){
  kgr_model1_results_WAIC[i] = pred_data = kgr_model1_results_list[[i]]$model_WAIC
}


saveRDS(kgr_model1_results_WAIC, paste0("kgr_model1_results_WAIC.rds"))


hist(kgr_model1_results_WAIC)
top5 = head(sort(kgr_model1_results_WAIC))
top5
top5_idx = which(kgr_model1_results_WAIC <= top5[5])

kgr_model1_results_WAIC = cbind(hyper_grid2,kgr_model1_results_WAIC)
colnames(kgr_model1_results_WAIC) = c(colnames(hyper_grid2),"WAIC")
kgr_model1_results_WAIC[top5_idx,]
```

Best hyperparameter values (so far): (rho_time_rbf, rho_time_periodic, sigma2_time) = (1,1,1000) , WAIC = 2798.259 

Finally, we could also increase the complexity of our proposed model by including our time kernel in the covariance structure of the underlying GP. Notice that K does not explicitly have a temporal dependence structure; instead, it represents EPA covariate similarity compared across months. We can explicitly include the time kernel above by either element wise adding or multiplying K_EPA and K_time together before taking the kronecker product with $H^2$

## Proposed model 3

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{it} | \textbf{X} = exp(\beta_0 + F_{it})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,(Ktime \odot K_{EPA}) \otimes H^2)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = k(t_1,t_2)k(x_{t_1},x_{t_2})(H^2)_{n_1,n_2}$.

```{r,warning=FALSE}
kgr_model3 = function(dataset,rho_EPA_rbf = 1,rho_EPA_periodic = 1,rho_time_rbf = 1,rho_time_periodic = 1,sigma2 = 1,link=1){
  
  ###Calculating gram matrix K_EPA
  K_EPA = EPA_kernel(time_span = length(unique(dataset$time)),
                     rho_rbf = rho_EPA_rbf,rho_periodic = rho_EPA_periodic,sigma2 = 1)
  
  #Heatmap of resulting K 
  #K_EPA_heatmap = matrix_heatmap(K_EPA,title = "K_EPA heatmap")
  
  ###Calculating gram matrix K_time
 K_time = time_kernel(time_span = length(unique(dataset$time)),rho_rbf = rho_time_rbf, 
                      rho_periodic = rho_time_periodic, sigma2 = sigma2)
  
  #Heatmap of resulting K 
  #K_time_heatmap = matrix_heatmap(K_time,title = "K_time heatmap")
  
  #Calculate trace norm of gram matrix
  gram = (K_EPA*K_time)/sigma2
  K_weight = norm(gram,type = "F")
  
  
  ###Load graph regression kernel 
  covGP3 = kronecker(gram/60,(H^2)/7)
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(covGP3,threshold = 1e-2,increment = 0.1)
  covGP3 = covGP_jittered[[1]]
  
  inv_covGP3 = solve(covGP3)
  
  #Heatmap of resulting K 
  #inv_covGP3_heatmap = matrix_heatmap(inv_covGP3,title = "Precision matrix heatmap")
  
  
  ###Fit INLA model 
  # kgr_formula3 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP3)
  
  # kgr_formula3 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP3)
  kgr_formula3 = response ~ -1 + months + Intercept1 + Intercept2 + f(id2,model = "generic0",Cmatrix = inv_covGP3)
  
  model = inla(formula = kgr_formula3,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE,
                                         return.marginals.predictor=TRUE),
                  control.inla = list(strategy = "gaussian"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  # marginal_fvs <- model$marginals.fitted.values
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  kgr_model3_results = list(
    # K_EPA_heatmap = K_EPA_heatmap,
    # K_time_heatmap = K_time_heatmap,
    # K_weight = K_weight/(K_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_weight + gfilter_weight),
    # covmatrix = covGP3,
    # prec = inv_covGP3,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_covGP3_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model,
    # marg_fitted_values = marginal_fvs
  )
  
  return(kgr_model3_results)
}
```

# Defining grid of hyperparameter value pairs

```{r,eval=FALSE}
rho_EPA_rbf_grid = seq(80,120,length=5)
rho_EPA_periodic_grid = seq(80,120,length=5)
rho_time_rbf_grid = seq(10,50,length=5)
rho_time_periodic_grid = seq(80,120,length=5)
sigma2_grid = seq(1,100,length=5)

hyper_grid = matrix(ncol=5)

for (i in rho_EPA_rbf_grid){
  for (j in rho_EPA_periodic_grid){
    for (k in rho_time_rbf_grid){
      for (l in rho_time_periodic_grid){
        for (m in sigma2_grid){
          hyper_grid = rbind(hyper_grid,c(i,j,k,l,m))
        }
      }
    }
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_EPA_rbf","rho_EPA_periodic","rho_time_rbf",
                         "rho_time_periodic","sigma2")
```

```{r}
hyper_grid2 = randomLHS(100,5)
colnames(hyper_grid2) = c("rho_EPA_rbf","rho_EPA_periodic","rho_time_rbf",
                         "rho_time_periodic","sigma2")

hyper_grid2[,1:4] = hyper_grid2[,1:4]*785
hyper_grid2[,5] = hyper_grid2[,5]*5 
```

```{r,warning=FALSE}
# kgr_model3_running_results = c()
# 
# apply_function <- function(row,index) {
#   rho_EPA_rbf <- row[1]
#   rho_EPA_periodic <- row[2]
#   rho_time_rbf <- row[3]
#   rho_time_periodic <- row[4]
#   sigma2 <- row[5]
#   
#   # Call kgr_model3 function with the specific hyperparameters
#   result <- kgr_model3(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
#                        rho_EPA_periodic = rho_EPA_periodic, rho_time_rbf = rho_time_rbf,
#                        rho_time_periodic = rho_time_periodic, sigma2 = sigma2)
#   
#   # Print and save WAIC every 100th model
#   if (index %% 20 == 0) {
#     cat("Model", index, "WAIC:", result$model_WAIC, "\n")
#     kgr_model3_running_results = c(kgr_model3_running_results , result$model_WAIC)
#     saveRDS(kgr_model3_running_results, paste0("kgr_model3_running_results_WAIC.rds"))
#   }
#   
#   # Return the result
#   return(result)
# }
# 
# kgr_model3_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
#   apply_function(hyper_grid2[i, ], i)
# })



apply_function <- function(row, index) {
  rho_EPA_rbf <- row[1]
  rho_EPA_periodic <- row[2]
  rho_time_rbf <- row[3]
  rho_time_periodic <- row[4]
  sigma2 <- row[5]

  result <- tryCatch(
    {
      kgr_model3(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
                       rho_EPA_periodic = rho_EPA_periodic, rho_time_rbf = rho_time_rbf,
                       rho_time_periodic = rho_time_periodic, sigma2 = sigma2)
    },
    error = function(e) {
      # Handle the error by printing a message and returning NULL
      cat("Error in model", index, ":", conditionMessage(e), "\n")
      return(NULL)
    }
  )

  # If result is not NULL, process the result
  if (!is.null(result)) {
    # Print and save WAIC every 5th model
    if (index %% 20 == 0) {
      cat("Model", index, "WAIC:", result$model_WAIC, "\n")
      kgr_model3_running_results <<- c(kgr_model3_running_results, result$model_WAIC)
      saveRDS(kgr_model3_running_results, paste0("kgr_model3_running_results_WAIC.rds"))
    }
  }

  # Return the result (which could be NULL if there was an error)
  return(result)
}

kgr_model3_running_results <- vector()  # Initialize an empty vector to store WAIC results

kgr_model3_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# Remove NULL results from the list if needed
kgr_model3_results_list <- Filter(Negate(is.null), kgr_model3_results_list)


# #Posterior predictive plots
# for (i in 1:length(kgr_model3_results_list)){
#   pp_insample_plot(pred_data = kgr_model3_results_list[[i]]$fitted_values)
# }


#Extracting DIC values 
kgr_model3_results_DIC = c()

for (i in 1:length(kgr_model3_results_list)){
  kgr_model3_results_DIC[i] = pred_data = kgr_model3_results_list[[i]]$model_DIC
}

hist(kgr_model3_results_DIC)
top5 = head(sort(kgr_model3_results_DIC))
top5
which(kgr_model3_results_DIC <= top5[5])

kgr_model3_results_DIC = cbind(hyper_grid2,kgr_model3_results_DIC)

#Extracting WAIC values 
kgr_model3_results_WAIC = c()

for (i in 1:length(kgr_model3_results_list)){
  kgr_model3_results_WAIC[i] = pred_data = kgr_model3_results_list[[i]]$model_WAIC
}

saveRDS(kgr_model3_results_WAIC, paste0("kgr_model3_results_WAIC.rds"))


hist(kgr_model3_results_WAIC)
top5 = head(sort(kgr_model3_results_WAIC))
top5
top5_idx = which(kgr_model3_results_WAIC <= top5[5])

kgr_model3_results_WAIC = cbind(hyper_grid2,kgr_model3_results_WAIC)
colnames(kgr_model3_results_WAIC) = c(colnames(hyper_grid2),"WAIC")
kgr_model3_results_WAIC[top5_idx,]

# #Plot WAIC values for each hyperparameter grid 
# for (i in 1:5){
#   plot(x = kgr_model3_results_WAIC[,i],y = kgr_model3_results_WAIC[,4],xlab = colnames(kgr_model3_results_WAIC)[i],ylab = "WAIC")
# }
```

Best hyperparameter values (so far): (rho_EPA_rbf, rho_EPA_periodic, rho_time_rbf, rho_time_periodic, sigma2) 
= (100,100,25.75,100,1) , WAIC= 2807.723 (sigma2 could be 1-100)    

```{r}
# somefvs = kgr_model3_results_list[[5]]$fitted_values
# pp_insample_plot(pred_data = somefvs)
# 
# bestfvs = kgr_model3_results_list[[25]]$fitted_values
# pp_insample_plot(pred_data = bestfvs)
```

## Proposed model 4

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{it} | \textbf{X} = exp(\beta_0 + F_{it})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,(Ktime + K_{EPA}) \otimes H^2)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = (k(t_1,t_2)+k(x_{t_1},x_{t_2}))(H^2)_{n_1,n_2}$.

```{r,warning=FALSE}
kgr_model4 = function(dataset,rho_EPA_rbf = 1,rho_EPA_periodic = 1,rho_time_rbf = 1,
                      rho_time_periodic = 1,sigma2_EPA = 1,sigma2_time = 1,link = 1){
  
  ###Calculating gram matrix K_EPA
  K_EPA = EPA_kernel(time_span = length(unique(dataset$time)),
                     rho_rbf = rho_EPA_rbf,rho_periodic = rho_EPA_periodic,sigma2 = 1)
  
  #Heatmap of resulting K 
  #K_EPA_heatmap = matrix_heatmap(K_EPA,title = "K_EPA heatmap")
  
  ###Calculating gram matrix K_time
  K_time = time_kernel(time_span = length(unique(dataset$time)),rho_rbf = rho_time_rbf, 
                    rho_periodic = rho_time_periodic, sigma2 = sigma2_time)
  
  #Heatmap of resulting K 
  #K_time_heatmap = matrix_heatmap(K_time,title = "K_time heatmap")
  
  gram = 0.5*(K_time+K_EPA)
  K_weight = norm(gram,type = "F")

  ###Load graph regression kernel 
  covGP4 = kronecker(gram/60,(H^2)/7)
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(covGP4,threshold = 1e-2,increment = 0.1)
  covGP4 = covGP_jittered[[1]]
  
  inv_covGP4 = solve(covGP4)
  
  #Heatmap of resulting K 
  #inv_covGP4_heatmap = matrix_heatmap(inv_covGP4,title = "Precision matrix heatmap")
  
  
  ###Fit INLA model 
  # kgr_formula4 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP4)
  
  # kgr_formula4 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP4)
  kgr_formula4 = response ~ -1 + months + Intercept1 + Intercept2 + f(id2,model = "generic0",Cmatrix = inv_covGP4)
  
  model = inla(formula = kgr_formula4,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE,
                                         return.marginals.predictor=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  # marginal_fvs <- model$marginals.fitted.values
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  kgr_model4_results = list(
    # K_EPA_heatmap = K_EPA_heatmap,
    # K_time_heatmap = K_time_heatmap,
    # K_weight = K_weight/(K_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_weight + gfilter_weight),
    # covmatrix = covGP4,
    # prec = inv_covGP4,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_covGP4_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model,
    # marg_fitted_values = marginal_fvs
  )
  
  return(kgr_model4_results)
}
```

# Defining grid of hyperparameter value pairs

```{r,eval=FALSE}
rho_EPA_rbf_grid = seq(80,120,length=3)
rho_EPA_periodic_grid = seq(60,80,length=3)

rho_time_rbf_grid = seq(1,3,length=3)
rho_time_periodic_grid = seq(100,150,length=3)

sigma2_EPA_grid = seq(1,5,length = 3)
sigma2_time_grid = seq(2,4,length = 3)

hyper_grid = matrix(ncol=6)

for (i in rho_EPA_rbf_grid){
  for (j in rho_EPA_periodic_grid){
    for (k in rho_time_rbf_grid){
      for (l in rho_time_periodic_grid){
        for (m in sigma2_EPA_grid){
          for (n in sigma2_time_grid){
            hyper_grid = rbind(hyper_grid,c(i,j,k,l,m,n))
          }
        }
      }
    }
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_EPA_rbf","rho_EPA_periodic","rho_time_rbf",
                         "rho_time_periodic","sigma2_EPA","sigma2_time")
```

```{r}
hyper_grid2 = randomLHS(100,6)
colnames(hyper_grid2) = c("rho_EPA_rbf","rho_EPA_periodic","rho_time_rbf",
                         "rho_time_periodic","sigma2_EPA","sigma2_time")
hyper_grid2[,1:4] = hyper_grid2[,1:4]*205 
hyper_grid2[,5:6] = hyper_grid2[,5:6]*5 
```

```{r,warning=FALSE}
# kgr_model4_running_results = list()
# 
# apply_function <- function(row,index) {
#   rho_EPA_rbf <- row[1]
#   rho_EPA_periodic <- row[2]
#   rho_time_rbf <- row[3]
#   rho_time_periodic <- row[4]
#   sigma2_EPA = row[5]
#   sigma2_time = row[6]
#   
#   # Call kgr_model4 function with the specific hyperparameters
#   result <- kgr_model4(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
#                        rho_EPA_periodic = rho_EPA_periodic, rho_time_rbf = rho_time_rbf,
#                        rho_time_periodic = rho_time_periodic, sigma2_EPA = sigma2_EPA, sigma2_time = sigma2_time)
#   
#   # Print and save WAIC every 100th model
#   if (index %% 20 == 0) {
#     cat("Model", index, "WAIC:", result$model_WAIC, "\n")
#     kgr_model4_running_results = c(kgr_model4_running_results , result$model_WAIC)
#     saveRDS(kgr_model4_running_results, paste0("kgr_model4_running_results_WAIC.rds"))
#   }
#   
#   # Return the result
#   return(result)
# }
# 
# kgr_model4_results_list <- lapply(seq_len(nrow(hyper_grid)), function(i) {
#   apply_function(hyper_grid[i, ], i)
# })


apply_function <- function(row, index) {
  rho_EPA_rbf <- row[1]
  rho_EPA_periodic <- row[2]
  rho_time_rbf <- row[3]
  rho_time_periodic <- row[4]
  sigma2_EPA = row[5]
  sigma2_time = row[6]

  result <- tryCatch(
    {
      kgr_model4(dataset = inla_insample_data, rho_EPA_rbf = rho_EPA_rbf,
                       rho_EPA_periodic = rho_EPA_periodic, rho_time_rbf = rho_time_rbf,
                       rho_time_periodic = rho_time_periodic, sigma2_EPA = sigma2_EPA, sigma2_time = sigma2_time)
    },
    error = function(e) {
      # Handle the error by printing a message and returning NULL
      cat("Error in model", index, ":", conditionMessage(e), "\n")
      return(NULL)
    }
  )

  # If result is not NULL, process the result
  if (!is.null(result)) {
    # Print and save WAIC every 5th model
    if (index %% 20 == 0) {
      cat("Model", index, "WAIC:", result$model_WAIC, "\n")
      kgr_model4_running_results <<- c(kgr_model4_running_results, result$model_WAIC)
      saveRDS(kgr_model4_running_results, paste0("kgr_model4_running_results_WAIC.rds"))
    }
  }

  # Return the result (which could be NULL if there was an error)
  return(result)
}

kgr_model4_running_results <- vector()  # Initialize an empty vector to store WAIC results

kgr_model4_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# Remove NULL results from the list if needed
kgr_model4_results_list <- Filter(Negate(is.null), kgr_model4_results_list)


# #Posterior predictive plots
# for (i in 1:length(kgr_model4_results_list)){
#   pp_insample_plot(pred_data = kgr_model4_results_list[[i]]$fitted_values)
# }


#Extracting DIC values 
kgr_model4_results_DIC = c()

for (i in 1:length(kgr_model4_results_list)){
  kgr_model4_results_DIC[i] = pred_data = kgr_model4_results_list[[i]]$model_DIC
}

hist(kgr_model4_results_DIC)
top5 = head(sort(kgr_model4_results_DIC))
top5
which(kgr_model4_results_DIC <= top5[5])

kgr_model4_results_DIC = cbind(hyper_grid2,kgr_model4_results_DIC)

#Extracting WAIC values 
kgr_model4_results_WAIC = c()

for (i in 1:length(kgr_model4_results_list)){
  kgr_model4_results_WAIC[i] = pred_data = kgr_model4_results_list[[i]]$model_WAIC
}

saveRDS(kgr_model4_results_WAIC, paste0("kgr_model4_results_WAIC.rds"))


hist(kgr_model4_results_WAIC)
top5 = head(sort(kgr_model4_results_WAIC))
top5
top5_idx = which(kgr_model4_results_WAIC <= top5[5])

kgr_model4_results_WAIC = cbind(hyper_grid2,kgr_model4_results_WAIC)
colnames(kgr_model4_results_WAIC) = c(colnames(hyper_grid2),"WAIC")
kgr_model4_results_WAIC[top5_idx,]

# #Plot WAIC values for each hyperparameter grid 
# for (i in 1:6){
#   plot(x = kgr_model4_results_WAIC[,i],y = kgr_model4_results_WAIC[,5],xlab = colnames(kgr_model4_results_WAIC)[i],ylab = "WAIC")
# }
```

Best hyperparameter values (so far): (rho_EPA_rbf, rho_EPA_periodi,c rho_time_rbf, rho_time_periodic, sigma2_EPA, sigma2_time) = (100,70,1,100/150,1/3/5,3) , WAIC = 2795.907


### Proposed model 5

$vec(Y) | \Lambda, \textbf{X} \sim Pois(vec(\Lambda))$ and $\Lambda_{it} | \textbf{X} = exp(\beta_0 + F_{it})$

where the graph signal $\textbf{F} | \textbf{X} \sim GP(0,\frac{1}{3}(K_{AR} + K_{DL} + K_{Interaction}) \otimes H^2)$ with $Cov[F_{n_1,t_1},F_{n_2,t_2}] = (k(t_1,t_2)+k(x_{t_1},x_{t_2}))(H^2)_{n_1,n_2}$.

```{r,warning=FALSE}
kgr_model5 = function(dataset, rho_AR_rbf = 1, rho_AR_periodic = 1, rho_DL_rbf = 1, rho_DL_periodic = 1,
                      rho_int_rbf = 1, rho_int_periodic = 1, sigma2_AR = 1, sigma2_DL = 1, sigma2_int = 1, link=1){
  
  #Calculating gram matrix K_AR
  K_AR_cluster = list()
  K_AR_periodic_cluster = list()
  
  for (c in 1:num_clus){
    
    #Grab S_random data for cluster c
    cluster_data = decomposed_cluster_data[[c]]
    S_random_clus = cluster_data$S_random
    
    #Create a list to contain covariance matrix for each pollutant (8)
    K_AR_list = list()
    K_AR_periodic_list = list()
    
    time_span = nrow(S_random_clus)
    
    #Calculate a AR 1 covariance matrix for each pollutant and store in list
    for (i in 1:8){
      ts =  S_random_clus[,i]
    
      K_covariate = matrix(nrow=time_span,ncol=time_span)
      K_covariate_periodic = matrix(nrow=time_span,ncol=time_span)
      
      for(j in 1:time_span){
        for (k in 1:time_span){
          if (abs(j-k) <= 1){
            
            K_covariate[j,k] = exp(- ((ts[j] - ts[k])^2) #RBF kernel 
                                 / (2*rho_AR_rbf)) * sigma2_AR
            
            K_covariate_periodic[j,k] = exp(- ((ts[j] - ts[k])^2) #Locally periodic kernel 
                         / (2*rho_AR_rbf)) * exp(- (2*sin((abs(ts[j] - ts[k]))*3.14/12)^2)
                         / (rho_AR_periodic)) * sigma2_AR
          }
          else{
            K_covariate_periodic[j,k] = 0
            K_covariate[j,k] = 0
            }
        }
      }
      
      K_AR_list[[i]] = K_covariate
      K_AR_periodic_list[[i]] = K_covariate_periodic
    }
    
    names(K_AR_list) = colnames(S_random_clus)
    names(K_AR_periodic_list) = colnames(S_random_clus)
    
    #Add each pollutant's covariance matrix to get AR 1 matrix for each cluster
    K_AR = matrix(0,nrow=60,ncol=60)
    K_AR_periodic = matrix(0,nrow=60,ncol=60)
    
    for(i in 1:length(K_AR_periodic_list)){
      K_AR = K_AR + ((1/8)*K_AR_list[[i]])
      K_AR_periodic = K_AR_periodic + ((1/8)*K_AR_periodic_list[[i]])
    }
    
    K_AR_cluster[[c]] = K_AR
    K_AR_periodic_cluster[[c]] = K_AR_periodic
  }
  
  K_AR = matrix(0,nrow=60,ncol=60)
  K_AR_periodic = matrix(0,nrow=60,ncol=60)
  
  for(i in 1:num_clus){
    K_AR = K_AR + ((1/num_clus)*K_AR_cluster[[i]])
    K_AR_periodic = K_AR_periodic + ((1/num_clus)*K_AR_periodic_cluster[[i]])
  }
  
  #Heatmap of resulting K 
  # K_AR_heatmap = corrplot(K_AR, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10),
  # title = "AR 1 Covariance Structure")
  # K_AR_heatmap = corrplot(K_AR_periodic, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10), title = "Periodic AR 1 Covariance Structure")
  
  # K_AR_heatmap = matrix_heatmap(K_AR,title = "AR 1 Covariance Structure")
  #K_AR_heatmap = matrix_heatmap(K_AR_periodic,title = "Periodic AR 1 Covariance Structure")

  ###Calculating gram matrix K_DL
  K_DL_cluster = list()
  K_DL_periodic_cluster = list()
  
  for (c in 1:num_clus){
    
    #Grab S_DL data for cluster c
    cluster_data = decomposed_cluster_data[[c]]
    S_DL_clus = cluster_data$S_DL
    
    #Create a list to store covariance matrix for each DL 
    K_DL_list = list()
    K_DL_periodic_list = list()
    
    dl_lags = c(3,6,12)
    tracker = 1
    
    for (i in dl_lags){
      
      K_DL = matrix(nrow=time_span,ncol=time_span)
      K_DL_periodic = matrix(nrow=time_span,ncol=time_span)
      
      #Calculate DL covariance matrix for specified lag   
      for(j in 1:nrow(S_DL_clus)){
        for (k in 1:nrow(S_DL_clus)){
          
          if ((abs(j-k) == 0) || (abs(j-k) == i)){
            
            K_DL[j,k] = exp(- (sum(S_DL_clus[j,] - S_DL_clus[k,])^2) / (2*rho_DL_rbf)) * sigma2_DL
            
            K_DL_periodic[j,k] = exp(- (sum(S_DL_clus[j,] - S_DL_clus[k,])^2)
                                 / (2*rho_DL_rbf)) * exp(- (2*sin(sum(abs(S_DL_clus[j,] - S_DL_clus[k,]))*3.14/12)^2)
                                 / (rho_DL_periodic)) * sigma2_DL
            
          } 
          else{
            K_DL_periodic[j,k] = 0
            K_DL[j,k] = 0
            }
        }
      }
      
      K_DL_list[[tracker]] = K_DL
      K_DL_periodic_list[[tracker]] = K_DL_periodic
      tracker = tracker+1
    }
    
    #Combine the 3 DL covariance matrices together
    K_DL = matrix(0,nrow=time_span,ncol=time_span)
    K_DL_periodic = matrix(0,nrow=time_span,ncol=time_span)
    
    for(i in 1:length(K_DL_periodic_list)){
      K_DL = K_DL + ((1/3)*K_DL_list[[i]])
      K_DL_periodic = K_DL_periodic + ((1/3)*K_DL_periodic_list[[i]])
    }
    
    #Store DL(3,6,12) covariance matrix for each cluster 
    K_DL_cluster[[c]] = K_DL
    K_DL_periodic_cluster[[c]] = K_DL
  }
  
  K_DL = matrix(0,nrow=time_span,ncol=time_span)
  K_DL_periodic = matrix(0,nrow=time_span,ncol=time_span)
  
  for(i in 1:num_clus){
    K_DL = K_DL + ((1/num_clus)*K_DL_cluster[[i]])
    K_DL_periodic = K_DL_periodic + ((1/num_clus)*K_DL_periodic_cluster[[i]])
  }
  
  #Heatmap of resulting K 
  # K_DL_heatmap = corrplot(K_DL, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10),
  # title = "DL (3,6,12) Covariance Structure")
  # K_DL_heatmap = corrplot(K_DL_periodic, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10), title = "Periodic DL (3,6,12) Covariance Structure")
  
  # K_DL_heatmap = matrix_heatmap(K_DL,title = "DL (3,6,12) Covariance Structure")
  #K_DL_heatmap = matrix_heatmap(K_DL_periodic,title = "Periodic DL (3,6,12) Covariance Structure")
  
  ###Calculating gram matrix K_Interaction
  K_Interaction_cluster = list()
  K_Interaction_periodic_cluster = list()
  
  for (c in 1:num_clus){
    
    #Grab interaction pair data for cluster c
    cluster_data = decomposed_cluster_data[[c]]
    W2_clus = cluster_data$W2
    
    K_interaction_list = list()
    K_interaction_periodic_list = list()
    
    column_names = colnames(W2_clus)
    time_span = nrow(W2_clus)
    
    #Create sequence of indices corresponding to comparisons for real time and one lag interaction effects
    lag0_idx = seq(2,3601,by=61)
    lag1_idx = seq(1,3600,by=61)
    
    #Calculate a kernel for each interaction pair 
    for (a in 1:length(column_names)){
      interaction =  W2_clus[,a]
      
      #First calculate these two interaction kernels separately 
      K_int0 = matrix(nrow = 60,ncol = 60)
      K_int1 = matrix(nrow = 60,ncol = 60)
      
      K_int0_periodic = matrix(nrow = 60,ncol = 60)
      K_int1_periodic = matrix(nrow = 60,ncol = 60)
      
      for (i in 1:60){
        for (j in 1:60){
          
          #RBF kernels
          K_int0[i,j] = exp(- ((interaction[lag0_idx[i]] - interaction[lag0_idx[j]])^2)
                              / (2*rho_int_rbf)) * sigma2_int
    
          K_int1[i,j] = exp(- ((interaction[lag1_idx[i]] - interaction[lag1_idx[j]])^2)
                              / (2*rho_int_rbf)) * sigma2_int
          
          #Locally periodic kernels 
          K_int0_periodic[i,j] = exp(- ((interaction[lag0_idx[i]] - interaction[lag0_idx[j]])^2)
                          / (2*rho_int_rbf)) * 
            exp(- (2*sin((abs(interaction[lag0_idx[i]] - interaction[lag0_idx[j]]))*3.14/12)^2)
                          / (rho_int_periodic)) * sigma2_int
              
          K_int1_periodic[i,j] = exp(- ((interaction[lag1_idx[i]] - interaction[lag1_idx[j]])^2)
                               / (2*rho_int_rbf)) * 
            exp(- (2*sin((abs(interaction[lag1_idx[i]] - interaction[lag1_idx[j]]))*3.14/12)^2)
                          / (rho_int_periodic)) * sigma2_int
        }
      }
      
      #Combine real time and one lag interaction kernels together
      K_interaction = 0.5*K_int0 + 0.5*K_int1
      K_interaction_list[[a]] = K_interaction
      
      K_interaction_periodic = 0.5*K_int0_periodic + 0.5*K_int1_periodic
      K_interaction_periodic_list[[a]] = K_interaction_periodic
    }
    
    #Combine kernels for each interaction pair together
    K_interaction = matrix(0,nrow=60,ncol=60)
    K_interaction_periodic = matrix(0,nrow=60,ncol=60)
    
    for(i in 1:length(K_interaction_periodic_list)){
      K_interaction = K_interaction + ((1/length(K_interaction_list))*K_interaction_list[[i]])
      
      K_interaction_periodic = K_interaction_periodic + ((1/length(K_interaction_periodic_list))*K_interaction_periodic_list[[i]])
    }

    #Store final interaction kernel (for all pairs) for each cluster 
    K_Interaction_cluster[[c]] = K_interaction
    K_Interaction_periodic_cluster[[c]] = K_interaction_periodic
  }
  
  K_interaction = matrix(0,nrow=60,ncol=60)
  K_interaction_periodic = matrix(0,nrow=60,ncol=60)
  
  for(i in 1:num_clus){
    K_interaction = K_interaction + ((1/length(K_Interaction_cluster))*K_Interaction_cluster[[i]])
    
    K_interaction_periodic = K_interaction_periodic + ((1/length(K_Interaction_periodic_cluster))*K_Interaction_periodic_cluster[[i]])
  }
  
  #Heatmap of resulting K 
  # K_Interaction_heatmap = corrplot(K_interaction, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10), title = "Interaction Covariance Structure")
  # K_Interaction_heatmap = corrplot(K_interaction_periodic, order = 'original', cl.pos = 'b', tl.pos = 'n',method = "color", col = COL1('YlOrRd',10), title = "Periodic Interaction Covariance Structure")
  
  # K_Interaction_heatmap = matrix_heatmap(K_interaction,title = "Interaction Covariance Structure")
  # K_Interaction_heatmap = matrix_heatmap(K_interaction_periodic,title = "Periodic Interaction Covariance Structure")
  
  gram = (1/3)*(K_AR_periodic+K_DL_periodic+K_interaction_periodic)
  K_weight = norm(gram,type = "F")
  
  ###Load graph regression kernel 
  covGP5 = kronecker(gram/60,(H^2)/7)
  
  #Need to ensure precision matrix is not computationally singular i.e det > 0
  covGP_jittered = desingularize(covGP5,threshold = 1e-2,increment = 0.5)
  covGP5 = covGP_jittered[[1]]
  
  inv_covGP5 = solve(covGP5)
  
  #Heatmap of resulting K 
  #inv_covGP5_heatmap = matrix_heatmap(inv_covGP5,title = "Precision matrix heatmap")
  
  
  ###Fit INLA model 
  # kgr_formula5 = response ~ -1 + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP5)
  
  # kgr_formula5 = response ~ -1 + months + Intercept1 + Intercept2 + Intercept3 + Intercept4 + 
  #   Intercept5 + Intercept6 + Intercept7 + f(id2,model = "generic0",Cmatrix = inv_covGP5)
  kgr_formula5 = response ~ -1 + months + Intercept1 + Intercept2 + f(id2,model = "generic0",Cmatrix = inv_covGP5)
  
  model = inla(formula = kgr_formula5,family = "poisson",data = dataset,
                  control.compute = list(dic=TRUE,waic=TRUE,
                                         return.marginals.predictor=TRUE),
                  control.inla = list(strategy = "laplace"),
                  control.predictor = list(compute = TRUE, link = link))
  
  ###Extract relevant information and store in the list
  # model_summary <- model$summary.fixed
  # bri_hyperpar_summary <- bri.hyperpar.summary(model)
  model_DIC <- model$dic$dic
  model_WAIC <- model$waic$waic
  # preds_model <- model$summary.fitted.values
  # preds_model <- cbind(dataset$id, dataset$time, preds_model)
  # colnames(preds_model) <- c("id", "time", "mean", "sd", "0.025quant", "0.5quant", "0.975quant", "mode")
  # marginal_fvs <- model$marginals.fitted.values
  
  # #Exponentiating parameter to get better interpretation of estimates 
  # multeff <- exp(model$summary.fixed$mean)
  # names(multeff) <- model$names.fixed
  # 
  # #Plot of each parameters' posterior density 
  # mf <- melt(model$marginals.fixed)
  # cf <- spread(mf,Var2,value)
  # names(cf)[2] <- 'parameter'
  # param_plot = ggplot(cf,aes(x=x,y=y)) + geom_line()+facet_wrap(~ parameter, 
  #            scales="free") + geom_vline(xintercept=0) + ylab("density")
  # 
  # #Plot of precision of random effect (main hyperparameter of interest)
  # sden <- data.frame(bri.hyper.sd(model$marginals.hyperpar[[1]]))
  # hyperparam_plot = ggplot(sden,aes(x,y)) + geom_line() + ylab("density") + 
  #            xlab("linear predictor")
  
  #Store the results in the list
  kgr_model5_results = list(
    # K_AR_heatmap = K_AR_heatmap, 
    # K_DL_heatmap = K_DL_heatmap,
    # K_Interaction_heatmap = K_Interaction_heatmap,
    # K_weight = K_weight/(K_weight + gfilter_weight),
    # gfilter_weight = gfilter_weight/(K_weight + gfilter_weight),
    # covmatrix = covGP5,
    # prec = inv_covGP5,
    # num_jitters = covGP_jittered[[2]],
    # prec_heatmap = inv_covGP5_heatmap,
    # model_summary = model_summary,
    # bri_hyperpar_summary = bri_hyperpar_summary,
    # exp_effects = multeff,
    # param_plot = param_plot,
    # hyperparam_plot = hyperparam_plot,
    model_DIC = model_DIC,
    model_WAIC = model_WAIC
    # fitted_values = preds_model,
    # marg_fitted_values = marginal_fvs
  )
  
  return(kgr_model5_results)
}
```

# Defining grid of hyperparameter value pairs

```{r,eval=FALSE}
rho_AR_rbf_grid = seq(1,100,length=3)
rho_DL_rbf_grid = seq(1,100,length=3)
rho_int_rbf_grid = seq(1,100,length=3)

rho_AR_periodic_grid = seq(1,100,length=3)
rho_DL_periodic_grid = seq(1,100,length=3)
rho_int_periodic_grid = seq(1,100,length=3)

sigma2_AR_grid = seq(1,100,length=3)
sigma2_DL_grid = seq(1,100,length=3)
sigma2_int_grid = seq(1,100,length=3)

hyper_grid = matrix(ncol=9)

for (i in rho_AR_rbf_grid){
  for (j in rho_AR_periodic_grid){
    for (k in rho_DL_rbf_grid){
      for (l in rho_DL_periodic_grid){
        for (m in rho_int_rbf_grid){
          for (n in rho_int_periodic_grid){
            for (o in sigma2_AR_grid){
              for (p in sigma2_DL_grid){
                for (q in sigma2_int_grid){
                  hyper_grid = rbind(hyper_grid,c(i,j,k,l,m,n,o,p,q))
                }
              }
            }
          }
        }
      }
    }
  }
}

hyper_grid = hyper_grid[-1,]
colnames(hyper_grid) = c("rho_AR_rbf","rho_AR_periodic","rho_DL_rbf","rho_DL_periodic",
                         "rho_int_rbf","rho_int_periodic","sigma2_AR","sigma2_DL","sigma2_int")
```

```{r}
hyper_grid2 = randomLHS(100,9)
colnames(hyper_grid2) = c("rho_AR_rbf","rho_AR_periodic","rho_DL_rbf","rho_DL_periodic",
                         "rho_int_rbf","rho_int_periodic","sigma2_AR","sigma2_DL","sigma2_int")
hyper_grid2[,1:6] = hyper_grid2[,1:6]*0.015 
hyper_grid2[,7:9] = hyper_grid2[,7:9]*5
```


```{r,warning=FALSE}
apply_function <- function(row,index) {
  rho_AR_rbf <- row[1]
  rho_AR_periodic <- row[2]
  rho_DL_rbf <- row[3]
  rho_DL_periodic <- row[4]
  rho_int_rbf <- row[5]
  rho_int_periodic <- row[6]
  sigma2_AR <- row[7]
  sigma2_DL <- row[8]
  sigma2_int <- row[9]
  
  # Call kgr_model5 function with the specific hyperparameters
  result <- kgr_model5(dataset = inla_insample_data, rho_AR_rbf = rho_AR_rbf, 
                       rho_AR_periodic = rho_AR_periodic, rho_DL_rbf = rho_DL_rbf, 
                       rho_DL_periodic = rho_DL_periodic, rho_int_rbf = rho_int_rbf,
                       rho_int_periodic = rho_int_periodic, sigma2_AR = sigma2_AR, 
                       sigma2_DL = sigma2_DL, sigma2_int = sigma2_int, link=1)
  
# Print and save WAIC every 100th model
  if (index %% 5 == 0) {
    cat("Model", index, "WAIC:", result$model_WAIC, "\n")
    kgr_model5_running_results = c(kgr_model5_running_results , result$model_WAIC)
    saveRDS(kgr_model5_running_results, paste0("kgr_model5_running_results_WAIC.rds"))
  }
  
  # Return the result
  return(result)
}

kgr_model5_running_results <- vector()  # Initialize an empty vector to store WAIC results

kgr_model5_results_list <- lapply(seq_len(nrow(hyper_grid2)), function(i) {
  apply_function(hyper_grid2[i, ], i)
})

# #Posterior predictive plots
# for (i in 1:length(kgr_model5_results_list)){
#   pp_insample_plot(pred_data = kgr_model5_results_list[[i]]$fitted_values)
# }


# #Extracting DIC values 
# kgr_model5_results_DIC = c()
# 
# for (i in 1:length(kgr_model5_results_list)){
#   kgr_model5_results_DIC[i] = pred_data = kgr_model5_results_list[[i]]$model_DIC
# }
# 
# hist(kgr_model5_results_DIC)
# top5 = head(sort(kgr_model5_results_DIC))
# top5
# which(kgr_model5_results_DIC <= top5[5])
# 
# kgr_model5_results_DIC = cbind(hyper_grid,kgr_model5_results_DIC)

#Extracting WAIC values 
kgr_model5_results_WAIC = c()

for (i in 1:length(kgr_model5_results_list)){
  kgr_model5_results_WAIC[i] = pred_data = kgr_model5_results_list[[i]]$model_WAIC
}

saveRDS(kgr_model5_results_WAIC, paste0("kgr_model5_results_WAIC.rds"))

hist(kgr_model5_results_WAIC)
top5 = head(sort(kgr_model5_results_WAIC))
top5
top5_idx = which(kgr_model5_results_WAIC <= top5[5])

kgr_model5_results_WAIC = cbind(hyper_grid2,kgr_model5_results_WAIC)
colnames(kgr_model5_results_WAIC) = c(colnames(hyper_grid2),"WAIC")
kgr_model5_results_WAIC[top5_idx,]

#Plot WAIC values for each hyperparameter grid 
# for (i in 1:9){
#   plot(x = kgr_model5_results_WAIC[,i],y = kgr_model5_results_WAIC[,5],xlab = colnames(kgr_model5_results_WAIC)[i],ylab = "WAIC")
# }
```
